// Code generated by column.go.tmpl.
// DO NOT EDIT.

package feather

import (
	"bytes"
	"encoding/binary"
	"errors"
	"fmt"

	flatbuffers "github.com/google/flatbuffers/go"
	"github.com/influxdata/arrow"
	"github.com/sglyon/feather/fbs"
)

// FeatherColumn is an interface defining core functionality necessary for
// reading a feather formatted column of any data type
type FeatherColumn interface {
	Name() string
	Length() int
	Type() int8
	TypeString() string
	NullN() int64
}

var (
	// BitMask is a byte slice such that BitMask[i] == (1 << i)
	BitMask = [8]byte{1, 2, 4, 8, 16, 32, 64, 128}
)

func bitIsSet(buf []byte, i int) bool {
	return (buf[uint(i)/8] & BitMask[i%8]) != 0
}

// Int8Column is a type that represents an immutable sequence of int8 values.
type Int8Column struct {
	name           string
	values         *fbs.PrimitiveArray
	nNull          int64
	src            *Source
	typE           int8
	offset, length int64
}

// NewInt8Column constructs a new Int8Column given the Source and column description from flatbuffers metadata
func NewInt8Column(src *Source, vals *fbs.PrimitiveArray, name string) *Int8Column {
	// TODO: typecheck for col.Values().TypE to match Int8
	if vals.TypE() != fbs.TypEINT8 {
		panic("Expected type int8, but found something else...")
	}
	return &Int8Column{
		name:   name,
		values: vals,
		nNull:  vals.NullCount(),
		src:    src,
		typE:   vals.TypE(),
		offset: vals.Offset(),
		length: vals.Length(),
	}
}

// Value extracts a single value from location i and whether that value is
// non-null. If null, then the result will be (0, false)
func (a *Int8Column) Value(i int) (int8, bool) {
	off := a.offset
	if a.nNull > 0 {
		// There might be nulls -- need to check bit
		thebyte := a.src.Data.At(int(off) + int(uint(i)/8)) // read single byte
		if (thebyte & BitMask[i%8]) == 0 {                  // check if bit is set in byte
			return 0, false
		}
		off += a.src.getBitmaskLength()
	}
	var out int8
	buf := make([]byte, 1)
	off += int64(i) * 1
	a.src.Data.ReadAt(buf, off)

	binary.Read(bytes.NewBuffer(buf), binary.LittleEndian, &out)
	return out, true
}

// Values extracts slices of all values as well as a []bool indicating validity
// of all elements. If there are no null values, then the second slice will be
// nil. An entry of false in the second slice indicates that the corresponding
// value is null
func (a *Int8Column) Values() ([]int8, []bool) {
	off := a.offset

	var outValid []bool
	var bitmaskLength int64

	if a.nNull > 0 {
		outValid = make([]bool, a.length)
		bitmaskLength = a.src.getBitmaskLength()
		thebyte := make([]byte, bitmaskLength)
		a.src.Data.ReadAt(thebyte, off)
		for i := 0; i < int(a.length); i++ {
			outValid[i] = bitIsSet(thebyte, i)
		}
	}

	off += bitmaskLength

	valbuf := make([]byte, a.length*1)
	a.src.Data.ReadAt(valbuf, off)
	outVals := arrow.Int8Traits.CastFromBytes(valbuf)

	return outVals, outValid
}

// Name returns the name of the column
func (a *Int8Column) Name() string { return a.name }

// Length returns the number of rows in the column
func (a *Int8Column) Length() int { return int(a.length) }

// Type returns an integer specifying the data typed contained by the column
func (a *Int8Column) Type() int8 { return a.typE }

// TypeString returns a string describing the data typed contained by the column
func (a *Int8Column) TypeString() string { return fbs.EnumNamesTypE[int8(a.typE)] }

// NullN returns how many null values there are in the column
func (a *Int8Column) NullN() int64 { return a.nNull }

// Int8FullColumn is a type that represents an immutable sequence of int8 values with no missing data
type Int8FullColumn struct {
	name           string
	values         *fbs.PrimitiveArray
	src            *Source
	typE           int8
	offset, length int64
}

// NewInt8FullColumn constructs a new Int8FullColumn given the Source and column description from flatbuffers metadata
func NewInt8FullColumn(src *Source, vals *fbs.PrimitiveArray, name string) *Int8FullColumn {
	// TODO: typecheck for col.Values().TypE to match Int8
	if vals.TypE() != fbs.TypEINT8 {
		panic("Expected type int8, but found something else...")
	}
	return &Int8FullColumn{
		name:   name,
		values: vals,
		src:    src,
		typE:   vals.TypE(),
		offset: vals.Offset(),
		length: vals.Length(),
	}
}

// Value extracts a single value from location i and whether
func (a *Int8FullColumn) Value(i int) int8 {
	off := a.offset
	var out int8
	buf := make([]byte, 1)
	off += int64(i) * 1
	a.src.Data.ReadAt(buf, off)

	binary.Read(bytes.NewBuffer(buf), binary.LittleEndian, &out)
	return out
}

// Values extracts slices of all values in the column
func (a *Int8FullColumn) Values() []int8 {
	valbuf := make([]byte, a.length*1)
	a.src.Data.ReadAt(valbuf, a.offset)
	return arrow.Int8Traits.CastFromBytes(valbuf)
}

// ToFullColumn converts the Column to one without a bitmask, if possible. Will return an error if nulls are present
func (a *Int8Column) ToFullColumn() (*Int8FullColumn, error) {
	if a.nNull > 0 {
		return nil, errors.New("Nulls present, cannot convert to full column")
	}
	out := &Int8FullColumn{
		name:   a.name,
		values: a.values,
		src:    a.src,
		typE:   a.typE,
		offset: a.offset,
		length: a.length,
	}
	return out, nil
}

// ToFullColumn converts the Column to one without a bitmask, if possible. Will return an error if nulls are present
func (a *Int8FullColumn) ToFullColumn() (*Int8FullColumn, error) {
	return a, nil
}

// Name returns the name of the column
func (a *Int8FullColumn) Name() string { return a.name }

// Length returns the number of rows in the column
func (a *Int8FullColumn) Length() int { return int(a.length) }

// Type returns an integer specifying the data typed contained by the column
func (a *Int8FullColumn) Type() int8 { return a.typE }

// TypeString returns a string describing the data typed contained by the column
func (a *Int8FullColumn) TypeString() string { return fbs.EnumNamesTypE[int8(a.typE)] }

// NullN returns how many null values there are in the column
func (a *Int8FullColumn) NullN() int64 { return 0 }

// Int16Column is a type that represents an immutable sequence of int16 values.
type Int16Column struct {
	name           string
	values         *fbs.PrimitiveArray
	nNull          int64
	src            *Source
	typE           int8
	offset, length int64
}

// NewInt16Column constructs a new Int16Column given the Source and column description from flatbuffers metadata
func NewInt16Column(src *Source, vals *fbs.PrimitiveArray, name string) *Int16Column {
	// TODO: typecheck for col.Values().TypE to match Int16
	if vals.TypE() != fbs.TypEINT16 {
		panic("Expected type int16, but found something else...")
	}
	return &Int16Column{
		name:   name,
		values: vals,
		nNull:  vals.NullCount(),
		src:    src,
		typE:   vals.TypE(),
		offset: vals.Offset(),
		length: vals.Length(),
	}
}

// Value extracts a single value from location i and whether that value is
// non-null. If null, then the result will be (0, false)
func (a *Int16Column) Value(i int) (int16, bool) {
	off := a.offset
	if a.nNull > 0 {
		// There might be nulls -- need to check bit
		thebyte := a.src.Data.At(int(off) + int(uint(i)/8)) // read single byte
		if (thebyte & BitMask[i%8]) == 0 {                  // check if bit is set in byte
			return 0, false
		}
		off += a.src.getBitmaskLength()
	}
	var out int16
	buf := make([]byte, 2)
	off += int64(i) * 2
	a.src.Data.ReadAt(buf, off)

	binary.Read(bytes.NewBuffer(buf), binary.LittleEndian, &out)
	return out, true
}

// Values extracts slices of all values as well as a []bool indicating validity
// of all elements. If there are no null values, then the second slice will be
// nil. An entry of false in the second slice indicates that the corresponding
// value is null
func (a *Int16Column) Values() ([]int16, []bool) {
	off := a.offset

	var outValid []bool
	var bitmaskLength int64

	if a.nNull > 0 {
		outValid = make([]bool, a.length)
		bitmaskLength = a.src.getBitmaskLength()
		thebyte := make([]byte, bitmaskLength)
		a.src.Data.ReadAt(thebyte, off)
		for i := 0; i < int(a.length); i++ {
			outValid[i] = bitIsSet(thebyte, i)
		}
	}

	off += bitmaskLength

	valbuf := make([]byte, a.length*2)
	a.src.Data.ReadAt(valbuf, off)
	outVals := arrow.Int16Traits.CastFromBytes(valbuf)

	return outVals, outValid
}

// Name returns the name of the column
func (a *Int16Column) Name() string { return a.name }

// Length returns the number of rows in the column
func (a *Int16Column) Length() int { return int(a.length) }

// Type returns an integer specifying the data typed contained by the column
func (a *Int16Column) Type() int8 { return a.typE }

// TypeString returns a string describing the data typed contained by the column
func (a *Int16Column) TypeString() string { return fbs.EnumNamesTypE[int8(a.typE)] }

// NullN returns how many null values there are in the column
func (a *Int16Column) NullN() int64 { return a.nNull }

// Int16FullColumn is a type that represents an immutable sequence of int16 values with no missing data
type Int16FullColumn struct {
	name           string
	values         *fbs.PrimitiveArray
	src            *Source
	typE           int8
	offset, length int64
}

// NewInt16FullColumn constructs a new Int16FullColumn given the Source and column description from flatbuffers metadata
func NewInt16FullColumn(src *Source, vals *fbs.PrimitiveArray, name string) *Int16FullColumn {
	// TODO: typecheck for col.Values().TypE to match Int16
	if vals.TypE() != fbs.TypEINT16 {
		panic("Expected type int16, but found something else...")
	}
	return &Int16FullColumn{
		name:   name,
		values: vals,
		src:    src,
		typE:   vals.TypE(),
		offset: vals.Offset(),
		length: vals.Length(),
	}
}

// Value extracts a single value from location i and whether
func (a *Int16FullColumn) Value(i int) int16 {
	off := a.offset
	var out int16
	buf := make([]byte, 2)
	off += int64(i) * 2
	a.src.Data.ReadAt(buf, off)

	binary.Read(bytes.NewBuffer(buf), binary.LittleEndian, &out)
	return out
}

// Values extracts slices of all values in the column
func (a *Int16FullColumn) Values() []int16 {
	valbuf := make([]byte, a.length*2)
	a.src.Data.ReadAt(valbuf, a.offset)
	return arrow.Int16Traits.CastFromBytes(valbuf)
}

// ToFullColumn converts the Column to one without a bitmask, if possible. Will return an error if nulls are present
func (a *Int16Column) ToFullColumn() (*Int16FullColumn, error) {
	if a.nNull > 0 {
		return nil, errors.New("Nulls present, cannot convert to full column")
	}
	out := &Int16FullColumn{
		name:   a.name,
		values: a.values,
		src:    a.src,
		typE:   a.typE,
		offset: a.offset,
		length: a.length,
	}
	return out, nil
}

// ToFullColumn converts the Column to one without a bitmask, if possible. Will return an error if nulls are present
func (a *Int16FullColumn) ToFullColumn() (*Int16FullColumn, error) {
	return a, nil
}

// Name returns the name of the column
func (a *Int16FullColumn) Name() string { return a.name }

// Length returns the number of rows in the column
func (a *Int16FullColumn) Length() int { return int(a.length) }

// Type returns an integer specifying the data typed contained by the column
func (a *Int16FullColumn) Type() int8 { return a.typE }

// TypeString returns a string describing the data typed contained by the column
func (a *Int16FullColumn) TypeString() string { return fbs.EnumNamesTypE[int8(a.typE)] }

// NullN returns how many null values there are in the column
func (a *Int16FullColumn) NullN() int64 { return 0 }

// Int32Column is a type that represents an immutable sequence of int32 values.
type Int32Column struct {
	name           string
	values         *fbs.PrimitiveArray
	nNull          int64
	src            *Source
	typE           int8
	offset, length int64
}

// NewInt32Column constructs a new Int32Column given the Source and column description from flatbuffers metadata
func NewInt32Column(src *Source, vals *fbs.PrimitiveArray, name string) *Int32Column {
	// TODO: typecheck for col.Values().TypE to match Int32
	if vals.TypE() != fbs.TypEINT32 {
		panic("Expected type int32, but found something else...")
	}
	return &Int32Column{
		name:   name,
		values: vals,
		nNull:  vals.NullCount(),
		src:    src,
		typE:   vals.TypE(),
		offset: vals.Offset(),
		length: vals.Length(),
	}
}

// Value extracts a single value from location i and whether that value is
// non-null. If null, then the result will be (0, false)
func (a *Int32Column) Value(i int) (int32, bool) {
	off := a.offset
	if a.nNull > 0 {
		// There might be nulls -- need to check bit
		thebyte := a.src.Data.At(int(off) + int(uint(i)/8)) // read single byte
		if (thebyte & BitMask[i%8]) == 0 {                  // check if bit is set in byte
			return 0, false
		}
		off += a.src.getBitmaskLength()
	}
	var out int32
	buf := make([]byte, 4)
	off += int64(i) * 4
	a.src.Data.ReadAt(buf, off)

	binary.Read(bytes.NewBuffer(buf), binary.LittleEndian, &out)
	return out, true
}

// Values extracts slices of all values as well as a []bool indicating validity
// of all elements. If there are no null values, then the second slice will be
// nil. An entry of false in the second slice indicates that the corresponding
// value is null
func (a *Int32Column) Values() ([]int32, []bool) {
	off := a.offset

	var outValid []bool
	var bitmaskLength int64

	if a.nNull > 0 {
		outValid = make([]bool, a.length)
		bitmaskLength = a.src.getBitmaskLength()
		thebyte := make([]byte, bitmaskLength)
		a.src.Data.ReadAt(thebyte, off)
		for i := 0; i < int(a.length); i++ {
			outValid[i] = bitIsSet(thebyte, i)
		}
	}

	off += bitmaskLength

	valbuf := make([]byte, a.length*4)
	a.src.Data.ReadAt(valbuf, off)
	outVals := arrow.Int32Traits.CastFromBytes(valbuf)

	return outVals, outValid
}

// Name returns the name of the column
func (a *Int32Column) Name() string { return a.name }

// Length returns the number of rows in the column
func (a *Int32Column) Length() int { return int(a.length) }

// Type returns an integer specifying the data typed contained by the column
func (a *Int32Column) Type() int8 { return a.typE }

// TypeString returns a string describing the data typed contained by the column
func (a *Int32Column) TypeString() string { return fbs.EnumNamesTypE[int8(a.typE)] }

// NullN returns how many null values there are in the column
func (a *Int32Column) NullN() int64 { return a.nNull }

// Int32FullColumn is a type that represents an immutable sequence of int32 values with no missing data
type Int32FullColumn struct {
	name           string
	values         *fbs.PrimitiveArray
	src            *Source
	typE           int8
	offset, length int64
}

// NewInt32FullColumn constructs a new Int32FullColumn given the Source and column description from flatbuffers metadata
func NewInt32FullColumn(src *Source, vals *fbs.PrimitiveArray, name string) *Int32FullColumn {
	// TODO: typecheck for col.Values().TypE to match Int32
	if vals.TypE() != fbs.TypEINT32 {
		panic("Expected type int32, but found something else...")
	}
	return &Int32FullColumn{
		name:   name,
		values: vals,
		src:    src,
		typE:   vals.TypE(),
		offset: vals.Offset(),
		length: vals.Length(),
	}
}

// Value extracts a single value from location i and whether
func (a *Int32FullColumn) Value(i int) int32 {
	off := a.offset
	var out int32
	buf := make([]byte, 4)
	off += int64(i) * 4
	a.src.Data.ReadAt(buf, off)

	binary.Read(bytes.NewBuffer(buf), binary.LittleEndian, &out)
	return out
}

// Values extracts slices of all values in the column
func (a *Int32FullColumn) Values() []int32 {
	valbuf := make([]byte, a.length*4)
	a.src.Data.ReadAt(valbuf, a.offset)
	return arrow.Int32Traits.CastFromBytes(valbuf)
}

// ToFullColumn converts the Column to one without a bitmask, if possible. Will return an error if nulls are present
func (a *Int32Column) ToFullColumn() (*Int32FullColumn, error) {
	if a.nNull > 0 {
		return nil, errors.New("Nulls present, cannot convert to full column")
	}
	out := &Int32FullColumn{
		name:   a.name,
		values: a.values,
		src:    a.src,
		typE:   a.typE,
		offset: a.offset,
		length: a.length,
	}
	return out, nil
}

// ToFullColumn converts the Column to one without a bitmask, if possible. Will return an error if nulls are present
func (a *Int32FullColumn) ToFullColumn() (*Int32FullColumn, error) {
	return a, nil
}

// Name returns the name of the column
func (a *Int32FullColumn) Name() string { return a.name }

// Length returns the number of rows in the column
func (a *Int32FullColumn) Length() int { return int(a.length) }

// Type returns an integer specifying the data typed contained by the column
func (a *Int32FullColumn) Type() int8 { return a.typE }

// TypeString returns a string describing the data typed contained by the column
func (a *Int32FullColumn) TypeString() string { return fbs.EnumNamesTypE[int8(a.typE)] }

// NullN returns how many null values there are in the column
func (a *Int32FullColumn) NullN() int64 { return 0 }

// Int64Column is a type that represents an immutable sequence of int64 values.
type Int64Column struct {
	name           string
	values         *fbs.PrimitiveArray
	nNull          int64
	src            *Source
	typE           int8
	offset, length int64
}

// NewInt64Column constructs a new Int64Column given the Source and column description from flatbuffers metadata
func NewInt64Column(src *Source, vals *fbs.PrimitiveArray, name string) *Int64Column {
	// TODO: typecheck for col.Values().TypE to match Int64
	if vals.TypE() != fbs.TypEINT64 {
		panic("Expected type int64, but found something else...")
	}
	return &Int64Column{
		name:   name,
		values: vals,
		nNull:  vals.NullCount(),
		src:    src,
		typE:   vals.TypE(),
		offset: vals.Offset(),
		length: vals.Length(),
	}
}

// Value extracts a single value from location i and whether that value is
// non-null. If null, then the result will be (0, false)
func (a *Int64Column) Value(i int) (int64, bool) {
	off := a.offset
	if a.nNull > 0 {
		// There might be nulls -- need to check bit
		thebyte := a.src.Data.At(int(off) + int(uint(i)/8)) // read single byte
		if (thebyte & BitMask[i%8]) == 0 {                  // check if bit is set in byte
			return 0, false
		}
		off += a.src.getBitmaskLength()
	}
	var out int64
	buf := make([]byte, 8)
	off += int64(i) * 8
	a.src.Data.ReadAt(buf, off)

	binary.Read(bytes.NewBuffer(buf), binary.LittleEndian, &out)
	return out, true
}

// Values extracts slices of all values as well as a []bool indicating validity
// of all elements. If there are no null values, then the second slice will be
// nil. An entry of false in the second slice indicates that the corresponding
// value is null
func (a *Int64Column) Values() ([]int64, []bool) {
	off := a.offset

	var outValid []bool
	var bitmaskLength int64

	if a.nNull > 0 {
		outValid = make([]bool, a.length)
		bitmaskLength = a.src.getBitmaskLength()
		thebyte := make([]byte, bitmaskLength)
		a.src.Data.ReadAt(thebyte, off)
		for i := 0; i < int(a.length); i++ {
			outValid[i] = bitIsSet(thebyte, i)
		}
	}

	off += bitmaskLength

	valbuf := make([]byte, a.length*8)
	a.src.Data.ReadAt(valbuf, off)
	outVals := arrow.Int64Traits.CastFromBytes(valbuf)

	return outVals, outValid
}

// Name returns the name of the column
func (a *Int64Column) Name() string { return a.name }

// Length returns the number of rows in the column
func (a *Int64Column) Length() int { return int(a.length) }

// Type returns an integer specifying the data typed contained by the column
func (a *Int64Column) Type() int8 { return a.typE }

// TypeString returns a string describing the data typed contained by the column
func (a *Int64Column) TypeString() string { return fbs.EnumNamesTypE[int8(a.typE)] }

// NullN returns how many null values there are in the column
func (a *Int64Column) NullN() int64 { return a.nNull }

// Int64FullColumn is a type that represents an immutable sequence of int64 values with no missing data
type Int64FullColumn struct {
	name           string
	values         *fbs.PrimitiveArray
	src            *Source
	typE           int8
	offset, length int64
}

// NewInt64FullColumn constructs a new Int64FullColumn given the Source and column description from flatbuffers metadata
func NewInt64FullColumn(src *Source, vals *fbs.PrimitiveArray, name string) *Int64FullColumn {
	// TODO: typecheck for col.Values().TypE to match Int64
	if vals.TypE() != fbs.TypEINT64 {
		panic("Expected type int64, but found something else...")
	}
	return &Int64FullColumn{
		name:   name,
		values: vals,
		src:    src,
		typE:   vals.TypE(),
		offset: vals.Offset(),
		length: vals.Length(),
	}
}

// Value extracts a single value from location i and whether
func (a *Int64FullColumn) Value(i int) int64 {
	off := a.offset
	var out int64
	buf := make([]byte, 8)
	off += int64(i) * 8
	a.src.Data.ReadAt(buf, off)

	binary.Read(bytes.NewBuffer(buf), binary.LittleEndian, &out)
	return out
}

// Values extracts slices of all values in the column
func (a *Int64FullColumn) Values() []int64 {
	valbuf := make([]byte, a.length*8)
	a.src.Data.ReadAt(valbuf, a.offset)
	return arrow.Int64Traits.CastFromBytes(valbuf)
}

// ToFullColumn converts the Column to one without a bitmask, if possible. Will return an error if nulls are present
func (a *Int64Column) ToFullColumn() (*Int64FullColumn, error) {
	if a.nNull > 0 {
		return nil, errors.New("Nulls present, cannot convert to full column")
	}
	out := &Int64FullColumn{
		name:   a.name,
		values: a.values,
		src:    a.src,
		typE:   a.typE,
		offset: a.offset,
		length: a.length,
	}
	return out, nil
}

// ToFullColumn converts the Column to one without a bitmask, if possible. Will return an error if nulls are present
func (a *Int64FullColumn) ToFullColumn() (*Int64FullColumn, error) {
	return a, nil
}

// Name returns the name of the column
func (a *Int64FullColumn) Name() string { return a.name }

// Length returns the number of rows in the column
func (a *Int64FullColumn) Length() int { return int(a.length) }

// Type returns an integer specifying the data typed contained by the column
func (a *Int64FullColumn) Type() int8 { return a.typE }

// TypeString returns a string describing the data typed contained by the column
func (a *Int64FullColumn) TypeString() string { return fbs.EnumNamesTypE[int8(a.typE)] }

// NullN returns how many null values there are in the column
func (a *Int64FullColumn) NullN() int64 { return 0 }

// Uint8Column is a type that represents an immutable sequence of uint8 values.
type Uint8Column struct {
	name           string
	values         *fbs.PrimitiveArray
	nNull          int64
	src            *Source
	typE           int8
	offset, length int64
}

// NewUint8Column constructs a new Uint8Column given the Source and column description from flatbuffers metadata
func NewUint8Column(src *Source, vals *fbs.PrimitiveArray, name string) *Uint8Column {
	// TODO: typecheck for col.Values().TypE to match Uint8
	if vals.TypE() != fbs.TypEUINT8 {
		panic("Expected type uint8, but found something else...")
	}
	return &Uint8Column{
		name:   name,
		values: vals,
		nNull:  vals.NullCount(),
		src:    src,
		typE:   vals.TypE(),
		offset: vals.Offset(),
		length: vals.Length(),
	}
}

// Value extracts a single value from location i and whether that value is
// non-null. If null, then the result will be (0, false)
func (a *Uint8Column) Value(i int) (uint8, bool) {
	off := a.offset
	if a.nNull > 0 {
		// There might be nulls -- need to check bit
		thebyte := a.src.Data.At(int(off) + int(uint(i)/8)) // read single byte
		if (thebyte & BitMask[i%8]) == 0 {                  // check if bit is set in byte
			return 0, false
		}
		off += a.src.getBitmaskLength()
	}
	var out uint8
	buf := make([]byte, 1)
	off += int64(i) * 1
	a.src.Data.ReadAt(buf, off)

	binary.Read(bytes.NewBuffer(buf), binary.LittleEndian, &out)
	return out, true
}

// Values extracts slices of all values as well as a []bool indicating validity
// of all elements. If there are no null values, then the second slice will be
// nil. An entry of false in the second slice indicates that the corresponding
// value is null
func (a *Uint8Column) Values() ([]uint8, []bool) {
	off := a.offset

	var outValid []bool
	var bitmaskLength int64

	if a.nNull > 0 {
		outValid = make([]bool, a.length)
		bitmaskLength = a.src.getBitmaskLength()
		thebyte := make([]byte, bitmaskLength)
		a.src.Data.ReadAt(thebyte, off)
		for i := 0; i < int(a.length); i++ {
			outValid[i] = bitIsSet(thebyte, i)
		}
	}

	off += bitmaskLength

	valbuf := make([]byte, a.length*1)
	a.src.Data.ReadAt(valbuf, off)
	outVals := arrow.Uint8Traits.CastFromBytes(valbuf)

	return outVals, outValid
}

// Name returns the name of the column
func (a *Uint8Column) Name() string { return a.name }

// Length returns the number of rows in the column
func (a *Uint8Column) Length() int { return int(a.length) }

// Type returns an integer specifying the data typed contained by the column
func (a *Uint8Column) Type() int8 { return a.typE }

// TypeString returns a string describing the data typed contained by the column
func (a *Uint8Column) TypeString() string { return fbs.EnumNamesTypE[int8(a.typE)] }

// NullN returns how many null values there are in the column
func (a *Uint8Column) NullN() int64 { return a.nNull }

// Uint8FullColumn is a type that represents an immutable sequence of uint8 values with no missing data
type Uint8FullColumn struct {
	name           string
	values         *fbs.PrimitiveArray
	src            *Source
	typE           int8
	offset, length int64
}

// NewUint8FullColumn constructs a new Uint8FullColumn given the Source and column description from flatbuffers metadata
func NewUint8FullColumn(src *Source, vals *fbs.PrimitiveArray, name string) *Uint8FullColumn {
	// TODO: typecheck for col.Values().TypE to match Uint8
	if vals.TypE() != fbs.TypEUINT8 {
		panic("Expected type uint8, but found something else...")
	}
	return &Uint8FullColumn{
		name:   name,
		values: vals,
		src:    src,
		typE:   vals.TypE(),
		offset: vals.Offset(),
		length: vals.Length(),
	}
}

// Value extracts a single value from location i and whether
func (a *Uint8FullColumn) Value(i int) uint8 {
	off := a.offset
	var out uint8
	buf := make([]byte, 1)
	off += int64(i) * 1
	a.src.Data.ReadAt(buf, off)

	binary.Read(bytes.NewBuffer(buf), binary.LittleEndian, &out)
	return out
}

// Values extracts slices of all values in the column
func (a *Uint8FullColumn) Values() []uint8 {
	valbuf := make([]byte, a.length*1)
	a.src.Data.ReadAt(valbuf, a.offset)
	return arrow.Uint8Traits.CastFromBytes(valbuf)
}

// ToFullColumn converts the Column to one without a bitmask, if possible. Will return an error if nulls are present
func (a *Uint8Column) ToFullColumn() (*Uint8FullColumn, error) {
	if a.nNull > 0 {
		return nil, errors.New("Nulls present, cannot convert to full column")
	}
	out := &Uint8FullColumn{
		name:   a.name,
		values: a.values,
		src:    a.src,
		typE:   a.typE,
		offset: a.offset,
		length: a.length,
	}
	return out, nil
}

// ToFullColumn converts the Column to one without a bitmask, if possible. Will return an error if nulls are present
func (a *Uint8FullColumn) ToFullColumn() (*Uint8FullColumn, error) {
	return a, nil
}

// Name returns the name of the column
func (a *Uint8FullColumn) Name() string { return a.name }

// Length returns the number of rows in the column
func (a *Uint8FullColumn) Length() int { return int(a.length) }

// Type returns an integer specifying the data typed contained by the column
func (a *Uint8FullColumn) Type() int8 { return a.typE }

// TypeString returns a string describing the data typed contained by the column
func (a *Uint8FullColumn) TypeString() string { return fbs.EnumNamesTypE[int8(a.typE)] }

// NullN returns how many null values there are in the column
func (a *Uint8FullColumn) NullN() int64 { return 0 }

// Uint16Column is a type that represents an immutable sequence of uint16 values.
type Uint16Column struct {
	name           string
	values         *fbs.PrimitiveArray
	nNull          int64
	src            *Source
	typE           int8
	offset, length int64
}

// NewUint16Column constructs a new Uint16Column given the Source and column description from flatbuffers metadata
func NewUint16Column(src *Source, vals *fbs.PrimitiveArray, name string) *Uint16Column {
	// TODO: typecheck for col.Values().TypE to match Uint16
	if vals.TypE() != fbs.TypEUINT16 {
		panic("Expected type uint16, but found something else...")
	}
	return &Uint16Column{
		name:   name,
		values: vals,
		nNull:  vals.NullCount(),
		src:    src,
		typE:   vals.TypE(),
		offset: vals.Offset(),
		length: vals.Length(),
	}
}

// Value extracts a single value from location i and whether that value is
// non-null. If null, then the result will be (0, false)
func (a *Uint16Column) Value(i int) (uint16, bool) {
	off := a.offset
	if a.nNull > 0 {
		// There might be nulls -- need to check bit
		thebyte := a.src.Data.At(int(off) + int(uint(i)/8)) // read single byte
		if (thebyte & BitMask[i%8]) == 0 {                  // check if bit is set in byte
			return 0, false
		}
		off += a.src.getBitmaskLength()
	}
	var out uint16
	buf := make([]byte, 2)
	off += int64(i) * 2
	a.src.Data.ReadAt(buf, off)

	binary.Read(bytes.NewBuffer(buf), binary.LittleEndian, &out)
	return out, true
}

// Values extracts slices of all values as well as a []bool indicating validity
// of all elements. If there are no null values, then the second slice will be
// nil. An entry of false in the second slice indicates that the corresponding
// value is null
func (a *Uint16Column) Values() ([]uint16, []bool) {
	off := a.offset

	var outValid []bool
	var bitmaskLength int64

	if a.nNull > 0 {
		outValid = make([]bool, a.length)
		bitmaskLength = a.src.getBitmaskLength()
		thebyte := make([]byte, bitmaskLength)
		a.src.Data.ReadAt(thebyte, off)
		for i := 0; i < int(a.length); i++ {
			outValid[i] = bitIsSet(thebyte, i)
		}
	}

	off += bitmaskLength

	valbuf := make([]byte, a.length*2)
	a.src.Data.ReadAt(valbuf, off)
	outVals := arrow.Uint16Traits.CastFromBytes(valbuf)

	return outVals, outValid
}

// Name returns the name of the column
func (a *Uint16Column) Name() string { return a.name }

// Length returns the number of rows in the column
func (a *Uint16Column) Length() int { return int(a.length) }

// Type returns an integer specifying the data typed contained by the column
func (a *Uint16Column) Type() int8 { return a.typE }

// TypeString returns a string describing the data typed contained by the column
func (a *Uint16Column) TypeString() string { return fbs.EnumNamesTypE[int8(a.typE)] }

// NullN returns how many null values there are in the column
func (a *Uint16Column) NullN() int64 { return a.nNull }

// Uint16FullColumn is a type that represents an immutable sequence of uint16 values with no missing data
type Uint16FullColumn struct {
	name           string
	values         *fbs.PrimitiveArray
	src            *Source
	typE           int8
	offset, length int64
}

// NewUint16FullColumn constructs a new Uint16FullColumn given the Source and column description from flatbuffers metadata
func NewUint16FullColumn(src *Source, vals *fbs.PrimitiveArray, name string) *Uint16FullColumn {
	// TODO: typecheck for col.Values().TypE to match Uint16
	if vals.TypE() != fbs.TypEUINT16 {
		panic("Expected type uint16, but found something else...")
	}
	return &Uint16FullColumn{
		name:   name,
		values: vals,
		src:    src,
		typE:   vals.TypE(),
		offset: vals.Offset(),
		length: vals.Length(),
	}
}

// Value extracts a single value from location i and whether
func (a *Uint16FullColumn) Value(i int) uint16 {
	off := a.offset
	var out uint16
	buf := make([]byte, 2)
	off += int64(i) * 2
	a.src.Data.ReadAt(buf, off)

	binary.Read(bytes.NewBuffer(buf), binary.LittleEndian, &out)
	return out
}

// Values extracts slices of all values in the column
func (a *Uint16FullColumn) Values() []uint16 {
	valbuf := make([]byte, a.length*2)
	a.src.Data.ReadAt(valbuf, a.offset)
	return arrow.Uint16Traits.CastFromBytes(valbuf)
}

// ToFullColumn converts the Column to one without a bitmask, if possible. Will return an error if nulls are present
func (a *Uint16Column) ToFullColumn() (*Uint16FullColumn, error) {
	if a.nNull > 0 {
		return nil, errors.New("Nulls present, cannot convert to full column")
	}
	out := &Uint16FullColumn{
		name:   a.name,
		values: a.values,
		src:    a.src,
		typE:   a.typE,
		offset: a.offset,
		length: a.length,
	}
	return out, nil
}

// ToFullColumn converts the Column to one without a bitmask, if possible. Will return an error if nulls are present
func (a *Uint16FullColumn) ToFullColumn() (*Uint16FullColumn, error) {
	return a, nil
}

// Name returns the name of the column
func (a *Uint16FullColumn) Name() string { return a.name }

// Length returns the number of rows in the column
func (a *Uint16FullColumn) Length() int { return int(a.length) }

// Type returns an integer specifying the data typed contained by the column
func (a *Uint16FullColumn) Type() int8 { return a.typE }

// TypeString returns a string describing the data typed contained by the column
func (a *Uint16FullColumn) TypeString() string { return fbs.EnumNamesTypE[int8(a.typE)] }

// NullN returns how many null values there are in the column
func (a *Uint16FullColumn) NullN() int64 { return 0 }

// Uint32Column is a type that represents an immutable sequence of uint32 values.
type Uint32Column struct {
	name           string
	values         *fbs.PrimitiveArray
	nNull          int64
	src            *Source
	typE           int8
	offset, length int64
}

// NewUint32Column constructs a new Uint32Column given the Source and column description from flatbuffers metadata
func NewUint32Column(src *Source, vals *fbs.PrimitiveArray, name string) *Uint32Column {
	// TODO: typecheck for col.Values().TypE to match Uint32
	if vals.TypE() != fbs.TypEUINT32 {
		panic("Expected type uint32, but found something else...")
	}
	return &Uint32Column{
		name:   name,
		values: vals,
		nNull:  vals.NullCount(),
		src:    src,
		typE:   vals.TypE(),
		offset: vals.Offset(),
		length: vals.Length(),
	}
}

// Value extracts a single value from location i and whether that value is
// non-null. If null, then the result will be (0, false)
func (a *Uint32Column) Value(i int) (uint32, bool) {
	off := a.offset
	if a.nNull > 0 {
		// There might be nulls -- need to check bit
		thebyte := a.src.Data.At(int(off) + int(uint(i)/8)) // read single byte
		if (thebyte & BitMask[i%8]) == 0 {                  // check if bit is set in byte
			return 0, false
		}
		off += a.src.getBitmaskLength()
	}
	var out uint32
	buf := make([]byte, 4)
	off += int64(i) * 4
	a.src.Data.ReadAt(buf, off)

	binary.Read(bytes.NewBuffer(buf), binary.LittleEndian, &out)
	return out, true
}

// Values extracts slices of all values as well as a []bool indicating validity
// of all elements. If there are no null values, then the second slice will be
// nil. An entry of false in the second slice indicates that the corresponding
// value is null
func (a *Uint32Column) Values() ([]uint32, []bool) {
	off := a.offset

	var outValid []bool
	var bitmaskLength int64

	if a.nNull > 0 {
		outValid = make([]bool, a.length)
		bitmaskLength = a.src.getBitmaskLength()
		thebyte := make([]byte, bitmaskLength)
		a.src.Data.ReadAt(thebyte, off)
		for i := 0; i < int(a.length); i++ {
			outValid[i] = bitIsSet(thebyte, i)
		}
	}

	off += bitmaskLength

	valbuf := make([]byte, a.length*4)
	a.src.Data.ReadAt(valbuf, off)
	outVals := arrow.Uint32Traits.CastFromBytes(valbuf)

	return outVals, outValid
}

// Name returns the name of the column
func (a *Uint32Column) Name() string { return a.name }

// Length returns the number of rows in the column
func (a *Uint32Column) Length() int { return int(a.length) }

// Type returns an integer specifying the data typed contained by the column
func (a *Uint32Column) Type() int8 { return a.typE }

// TypeString returns a string describing the data typed contained by the column
func (a *Uint32Column) TypeString() string { return fbs.EnumNamesTypE[int8(a.typE)] }

// NullN returns how many null values there are in the column
func (a *Uint32Column) NullN() int64 { return a.nNull }

// Uint32FullColumn is a type that represents an immutable sequence of uint32 values with no missing data
type Uint32FullColumn struct {
	name           string
	values         *fbs.PrimitiveArray
	src            *Source
	typE           int8
	offset, length int64
}

// NewUint32FullColumn constructs a new Uint32FullColumn given the Source and column description from flatbuffers metadata
func NewUint32FullColumn(src *Source, vals *fbs.PrimitiveArray, name string) *Uint32FullColumn {
	// TODO: typecheck for col.Values().TypE to match Uint32
	if vals.TypE() != fbs.TypEUINT32 {
		panic("Expected type uint32, but found something else...")
	}
	return &Uint32FullColumn{
		name:   name,
		values: vals,
		src:    src,
		typE:   vals.TypE(),
		offset: vals.Offset(),
		length: vals.Length(),
	}
}

// Value extracts a single value from location i and whether
func (a *Uint32FullColumn) Value(i int) uint32 {
	off := a.offset
	var out uint32
	buf := make([]byte, 4)
	off += int64(i) * 4
	a.src.Data.ReadAt(buf, off)

	binary.Read(bytes.NewBuffer(buf), binary.LittleEndian, &out)
	return out
}

// Values extracts slices of all values in the column
func (a *Uint32FullColumn) Values() []uint32 {
	valbuf := make([]byte, a.length*4)
	a.src.Data.ReadAt(valbuf, a.offset)
	return arrow.Uint32Traits.CastFromBytes(valbuf)
}

// ToFullColumn converts the Column to one without a bitmask, if possible. Will return an error if nulls are present
func (a *Uint32Column) ToFullColumn() (*Uint32FullColumn, error) {
	if a.nNull > 0 {
		return nil, errors.New("Nulls present, cannot convert to full column")
	}
	out := &Uint32FullColumn{
		name:   a.name,
		values: a.values,
		src:    a.src,
		typE:   a.typE,
		offset: a.offset,
		length: a.length,
	}
	return out, nil
}

// ToFullColumn converts the Column to one without a bitmask, if possible. Will return an error if nulls are present
func (a *Uint32FullColumn) ToFullColumn() (*Uint32FullColumn, error) {
	return a, nil
}

// Name returns the name of the column
func (a *Uint32FullColumn) Name() string { return a.name }

// Length returns the number of rows in the column
func (a *Uint32FullColumn) Length() int { return int(a.length) }

// Type returns an integer specifying the data typed contained by the column
func (a *Uint32FullColumn) Type() int8 { return a.typE }

// TypeString returns a string describing the data typed contained by the column
func (a *Uint32FullColumn) TypeString() string { return fbs.EnumNamesTypE[int8(a.typE)] }

// NullN returns how many null values there are in the column
func (a *Uint32FullColumn) NullN() int64 { return 0 }

// Uint64Column is a type that represents an immutable sequence of uint64 values.
type Uint64Column struct {
	name           string
	values         *fbs.PrimitiveArray
	nNull          int64
	src            *Source
	typE           int8
	offset, length int64
}

// NewUint64Column constructs a new Uint64Column given the Source and column description from flatbuffers metadata
func NewUint64Column(src *Source, vals *fbs.PrimitiveArray, name string) *Uint64Column {
	// TODO: typecheck for col.Values().TypE to match Uint64
	if vals.TypE() != fbs.TypEUINT64 {
		panic("Expected type uint64, but found something else...")
	}
	return &Uint64Column{
		name:   name,
		values: vals,
		nNull:  vals.NullCount(),
		src:    src,
		typE:   vals.TypE(),
		offset: vals.Offset(),
		length: vals.Length(),
	}
}

// Value extracts a single value from location i and whether that value is
// non-null. If null, then the result will be (0, false)
func (a *Uint64Column) Value(i int) (uint64, bool) {
	off := a.offset
	if a.nNull > 0 {
		// There might be nulls -- need to check bit
		thebyte := a.src.Data.At(int(off) + int(uint(i)/8)) // read single byte
		if (thebyte & BitMask[i%8]) == 0 {                  // check if bit is set in byte
			return 0, false
		}
		off += a.src.getBitmaskLength()
	}
	var out uint64
	buf := make([]byte, 8)
	off += int64(i) * 8
	a.src.Data.ReadAt(buf, off)

	binary.Read(bytes.NewBuffer(buf), binary.LittleEndian, &out)
	return out, true
}

// Values extracts slices of all values as well as a []bool indicating validity
// of all elements. If there are no null values, then the second slice will be
// nil. An entry of false in the second slice indicates that the corresponding
// value is null
func (a *Uint64Column) Values() ([]uint64, []bool) {
	off := a.offset

	var outValid []bool
	var bitmaskLength int64

	if a.nNull > 0 {
		outValid = make([]bool, a.length)
		bitmaskLength = a.src.getBitmaskLength()
		thebyte := make([]byte, bitmaskLength)
		a.src.Data.ReadAt(thebyte, off)
		for i := 0; i < int(a.length); i++ {
			outValid[i] = bitIsSet(thebyte, i)
		}
	}

	off += bitmaskLength

	valbuf := make([]byte, a.length*8)
	a.src.Data.ReadAt(valbuf, off)
	outVals := arrow.Uint64Traits.CastFromBytes(valbuf)

	return outVals, outValid
}

// Name returns the name of the column
func (a *Uint64Column) Name() string { return a.name }

// Length returns the number of rows in the column
func (a *Uint64Column) Length() int { return int(a.length) }

// Type returns an integer specifying the data typed contained by the column
func (a *Uint64Column) Type() int8 { return a.typE }

// TypeString returns a string describing the data typed contained by the column
func (a *Uint64Column) TypeString() string { return fbs.EnumNamesTypE[int8(a.typE)] }

// NullN returns how many null values there are in the column
func (a *Uint64Column) NullN() int64 { return a.nNull }

// Uint64FullColumn is a type that represents an immutable sequence of uint64 values with no missing data
type Uint64FullColumn struct {
	name           string
	values         *fbs.PrimitiveArray
	src            *Source
	typE           int8
	offset, length int64
}

// NewUint64FullColumn constructs a new Uint64FullColumn given the Source and column description from flatbuffers metadata
func NewUint64FullColumn(src *Source, vals *fbs.PrimitiveArray, name string) *Uint64FullColumn {
	// TODO: typecheck for col.Values().TypE to match Uint64
	if vals.TypE() != fbs.TypEUINT64 {
		panic("Expected type uint64, but found something else...")
	}
	return &Uint64FullColumn{
		name:   name,
		values: vals,
		src:    src,
		typE:   vals.TypE(),
		offset: vals.Offset(),
		length: vals.Length(),
	}
}

// Value extracts a single value from location i and whether
func (a *Uint64FullColumn) Value(i int) uint64 {
	off := a.offset
	var out uint64
	buf := make([]byte, 8)
	off += int64(i) * 8
	a.src.Data.ReadAt(buf, off)

	binary.Read(bytes.NewBuffer(buf), binary.LittleEndian, &out)
	return out
}

// Values extracts slices of all values in the column
func (a *Uint64FullColumn) Values() []uint64 {
	valbuf := make([]byte, a.length*8)
	a.src.Data.ReadAt(valbuf, a.offset)
	return arrow.Uint64Traits.CastFromBytes(valbuf)
}

// ToFullColumn converts the Column to one without a bitmask, if possible. Will return an error if nulls are present
func (a *Uint64Column) ToFullColumn() (*Uint64FullColumn, error) {
	if a.nNull > 0 {
		return nil, errors.New("Nulls present, cannot convert to full column")
	}
	out := &Uint64FullColumn{
		name:   a.name,
		values: a.values,
		src:    a.src,
		typE:   a.typE,
		offset: a.offset,
		length: a.length,
	}
	return out, nil
}

// ToFullColumn converts the Column to one without a bitmask, if possible. Will return an error if nulls are present
func (a *Uint64FullColumn) ToFullColumn() (*Uint64FullColumn, error) {
	return a, nil
}

// Name returns the name of the column
func (a *Uint64FullColumn) Name() string { return a.name }

// Length returns the number of rows in the column
func (a *Uint64FullColumn) Length() int { return int(a.length) }

// Type returns an integer specifying the data typed contained by the column
func (a *Uint64FullColumn) Type() int8 { return a.typE }

// TypeString returns a string describing the data typed contained by the column
func (a *Uint64FullColumn) TypeString() string { return fbs.EnumNamesTypE[int8(a.typE)] }

// NullN returns how many null values there are in the column
func (a *Uint64FullColumn) NullN() int64 { return 0 }

// Float32Column is a type that represents an immutable sequence of float32 values.
type Float32Column struct {
	name           string
	values         *fbs.PrimitiveArray
	nNull          int64
	src            *Source
	typE           int8
	offset, length int64
}

// NewFloat32Column constructs a new Float32Column given the Source and column description from flatbuffers metadata
func NewFloat32Column(src *Source, vals *fbs.PrimitiveArray, name string) *Float32Column {
	// TODO: typecheck for col.Values().TypE to match Float32
	if vals.TypE() != fbs.TypEFLOAT {
		panic("Expected type float32, but found something else...")
	}
	return &Float32Column{
		name:   name,
		values: vals,
		nNull:  vals.NullCount(),
		src:    src,
		typE:   vals.TypE(),
		offset: vals.Offset(),
		length: vals.Length(),
	}
}

// Value extracts a single value from location i and whether that value is
// non-null. If null, then the result will be (0, false)
func (a *Float32Column) Value(i int) (float32, bool) {
	off := a.offset
	if a.nNull > 0 {
		// There might be nulls -- need to check bit
		thebyte := a.src.Data.At(int(off) + int(uint(i)/8)) // read single byte
		if (thebyte & BitMask[i%8]) == 0 {                  // check if bit is set in byte
			return 0, false
		}
		off += a.src.getBitmaskLength()
	}
	var out float32
	buf := make([]byte, 4)
	off += int64(i) * 4
	a.src.Data.ReadAt(buf, off)

	binary.Read(bytes.NewBuffer(buf), binary.LittleEndian, &out)
	return out, true
}

// Values extracts slices of all values as well as a []bool indicating validity
// of all elements. If there are no null values, then the second slice will be
// nil. An entry of false in the second slice indicates that the corresponding
// value is null
func (a *Float32Column) Values() ([]float32, []bool) {
	off := a.offset

	var outValid []bool
	var bitmaskLength int64

	if a.nNull > 0 {
		outValid = make([]bool, a.length)
		bitmaskLength = a.src.getBitmaskLength()
		thebyte := make([]byte, bitmaskLength)
		a.src.Data.ReadAt(thebyte, off)
		for i := 0; i < int(a.length); i++ {
			outValid[i] = bitIsSet(thebyte, i)
		}
	}

	off += bitmaskLength

	valbuf := make([]byte, a.length*4)
	a.src.Data.ReadAt(valbuf, off)
	outVals := arrow.Float32Traits.CastFromBytes(valbuf)

	return outVals, outValid
}

// Name returns the name of the column
func (a *Float32Column) Name() string { return a.name }

// Length returns the number of rows in the column
func (a *Float32Column) Length() int { return int(a.length) }

// Type returns an integer specifying the data typed contained by the column
func (a *Float32Column) Type() int8 { return a.typE }

// TypeString returns a string describing the data typed contained by the column
func (a *Float32Column) TypeString() string { return fbs.EnumNamesTypE[int8(a.typE)] }

// NullN returns how many null values there are in the column
func (a *Float32Column) NullN() int64 { return a.nNull }

// Float32FullColumn is a type that represents an immutable sequence of float32 values with no missing data
type Float32FullColumn struct {
	name           string
	values         *fbs.PrimitiveArray
	src            *Source
	typE           int8
	offset, length int64
}

// NewFloat32FullColumn constructs a new Float32FullColumn given the Source and column description from flatbuffers metadata
func NewFloat32FullColumn(src *Source, vals *fbs.PrimitiveArray, name string) *Float32FullColumn {
	// TODO: typecheck for col.Values().TypE to match Float32
	if vals.TypE() != fbs.TypEFLOAT {
		panic("Expected type float32, but found something else...")
	}
	return &Float32FullColumn{
		name:   name,
		values: vals,
		src:    src,
		typE:   vals.TypE(),
		offset: vals.Offset(),
		length: vals.Length(),
	}
}

// Value extracts a single value from location i and whether
func (a *Float32FullColumn) Value(i int) float32 {
	off := a.offset
	var out float32
	buf := make([]byte, 4)
	off += int64(i) * 4
	a.src.Data.ReadAt(buf, off)

	binary.Read(bytes.NewBuffer(buf), binary.LittleEndian, &out)
	return out
}

// Values extracts slices of all values in the column
func (a *Float32FullColumn) Values() []float32 {
	valbuf := make([]byte, a.length*4)
	a.src.Data.ReadAt(valbuf, a.offset)
	return arrow.Float32Traits.CastFromBytes(valbuf)
}

// ToFullColumn converts the Column to one without a bitmask, if possible. Will return an error if nulls are present
func (a *Float32Column) ToFullColumn() (*Float32FullColumn, error) {
	if a.nNull > 0 {
		return nil, errors.New("Nulls present, cannot convert to full column")
	}
	out := &Float32FullColumn{
		name:   a.name,
		values: a.values,
		src:    a.src,
		typE:   a.typE,
		offset: a.offset,
		length: a.length,
	}
	return out, nil
}

// ToFullColumn converts the Column to one without a bitmask, if possible. Will return an error if nulls are present
func (a *Float32FullColumn) ToFullColumn() (*Float32FullColumn, error) {
	return a, nil
}

// Name returns the name of the column
func (a *Float32FullColumn) Name() string { return a.name }

// Length returns the number of rows in the column
func (a *Float32FullColumn) Length() int { return int(a.length) }

// Type returns an integer specifying the data typed contained by the column
func (a *Float32FullColumn) Type() int8 { return a.typE }

// TypeString returns a string describing the data typed contained by the column
func (a *Float32FullColumn) TypeString() string { return fbs.EnumNamesTypE[int8(a.typE)] }

// NullN returns how many null values there are in the column
func (a *Float32FullColumn) NullN() int64 { return 0 }

// Float64Column is a type that represents an immutable sequence of float64 values.
type Float64Column struct {
	name           string
	values         *fbs.PrimitiveArray
	nNull          int64
	src            *Source
	typE           int8
	offset, length int64
}

// NewFloat64Column constructs a new Float64Column given the Source and column description from flatbuffers metadata
func NewFloat64Column(src *Source, vals *fbs.PrimitiveArray, name string) *Float64Column {
	// TODO: typecheck for col.Values().TypE to match Float64
	if vals.TypE() != fbs.TypEDOUBLE {
		panic("Expected type float64, but found something else...")
	}
	return &Float64Column{
		name:   name,
		values: vals,
		nNull:  vals.NullCount(),
		src:    src,
		typE:   vals.TypE(),
		offset: vals.Offset(),
		length: vals.Length(),
	}
}

// Value extracts a single value from location i and whether that value is
// non-null. If null, then the result will be (0, false)
func (a *Float64Column) Value(i int) (float64, bool) {
	off := a.offset
	if a.nNull > 0 {
		// There might be nulls -- need to check bit
		thebyte := a.src.Data.At(int(off) + int(uint(i)/8)) // read single byte
		if (thebyte & BitMask[i%8]) == 0 {                  // check if bit is set in byte
			return 0, false
		}
		off += a.src.getBitmaskLength()
	}
	var out float64
	buf := make([]byte, 8)
	off += int64(i) * 8
	a.src.Data.ReadAt(buf, off)

	binary.Read(bytes.NewBuffer(buf), binary.LittleEndian, &out)
	return out, true
}

// Values extracts slices of all values as well as a []bool indicating validity
// of all elements. If there are no null values, then the second slice will be
// nil. An entry of false in the second slice indicates that the corresponding
// value is null
func (a *Float64Column) Values() ([]float64, []bool) {
	off := a.offset

	var outValid []bool
	var bitmaskLength int64

	if a.nNull > 0 {
		outValid = make([]bool, a.length)
		bitmaskLength = a.src.getBitmaskLength()
		thebyte := make([]byte, bitmaskLength)
		a.src.Data.ReadAt(thebyte, off)
		for i := 0; i < int(a.length); i++ {
			outValid[i] = bitIsSet(thebyte, i)
		}
	}

	off += bitmaskLength

	valbuf := make([]byte, a.length*8)
	a.src.Data.ReadAt(valbuf, off)
	outVals := arrow.Float64Traits.CastFromBytes(valbuf)

	return outVals, outValid
}

// Name returns the name of the column
func (a *Float64Column) Name() string { return a.name }

// Length returns the number of rows in the column
func (a *Float64Column) Length() int { return int(a.length) }

// Type returns an integer specifying the data typed contained by the column
func (a *Float64Column) Type() int8 { return a.typE }

// TypeString returns a string describing the data typed contained by the column
func (a *Float64Column) TypeString() string { return fbs.EnumNamesTypE[int8(a.typE)] }

// NullN returns how many null values there are in the column
func (a *Float64Column) NullN() int64 { return a.nNull }

// Float64FullColumn is a type that represents an immutable sequence of float64 values with no missing data
type Float64FullColumn struct {
	name           string
	values         *fbs.PrimitiveArray
	src            *Source
	typE           int8
	offset, length int64
}

// NewFloat64FullColumn constructs a new Float64FullColumn given the Source and column description from flatbuffers metadata
func NewFloat64FullColumn(src *Source, vals *fbs.PrimitiveArray, name string) *Float64FullColumn {
	// TODO: typecheck for col.Values().TypE to match Float64
	if vals.TypE() != fbs.TypEDOUBLE {
		panic("Expected type float64, but found something else...")
	}
	return &Float64FullColumn{
		name:   name,
		values: vals,
		src:    src,
		typE:   vals.TypE(),
		offset: vals.Offset(),
		length: vals.Length(),
	}
}

// Value extracts a single value from location i and whether
func (a *Float64FullColumn) Value(i int) float64 {
	off := a.offset
	var out float64
	buf := make([]byte, 8)
	off += int64(i) * 8
	a.src.Data.ReadAt(buf, off)

	binary.Read(bytes.NewBuffer(buf), binary.LittleEndian, &out)
	return out
}

// Values extracts slices of all values in the column
func (a *Float64FullColumn) Values() []float64 {
	valbuf := make([]byte, a.length*8)
	a.src.Data.ReadAt(valbuf, a.offset)
	return arrow.Float64Traits.CastFromBytes(valbuf)
}

// ToFullColumn converts the Column to one without a bitmask, if possible. Will return an error if nulls are present
func (a *Float64Column) ToFullColumn() (*Float64FullColumn, error) {
	if a.nNull > 0 {
		return nil, errors.New("Nulls present, cannot convert to full column")
	}
	out := &Float64FullColumn{
		name:   a.name,
		values: a.values,
		src:    a.src,
		typE:   a.typE,
		offset: a.offset,
		length: a.length,
	}
	return out, nil
}

// ToFullColumn converts the Column to one without a bitmask, if possible. Will return an error if nulls are present
func (a *Float64FullColumn) ToFullColumn() (*Float64FullColumn, error) {
	return a, nil
}

// Name returns the name of the column
func (a *Float64FullColumn) Name() string { return a.name }

// Length returns the number of rows in the column
func (a *Float64FullColumn) Length() int { return int(a.length) }

// Type returns an integer specifying the data typed contained by the column
func (a *Float64FullColumn) Type() int8 { return a.typE }

// TypeString returns a string describing the data typed contained by the column
func (a *Float64FullColumn) TypeString() string { return fbs.EnumNamesTypE[int8(a.typE)] }

// NullN returns how many null values there are in the column
func (a *Float64FullColumn) NullN() int64 { return 0 }

// StringColumn is a type that represents an immutable sequence of string values.
type StringColumn struct {
	name           string
	values         *fbs.PrimitiveArray
	nNull          int64
	src            *Source
	typE           int8
	offset, length int64
}

// NewStringColumn constructs a new StringColumn given the Source and column description from flatbuffers metadata
func NewStringColumn(src *Source, vals *fbs.PrimitiveArray, name string) *StringColumn {
	// TODO: typecheck for col.Values().TypE to match String
	if vals.TypE() != fbs.TypEUTF8 {
		panic("Expected type string, but found something else...")
	}
	return &StringColumn{
		name:   name,
		values: vals,
		nNull:  vals.NullCount(),
		src:    src,
		typE:   vals.TypE(),
		offset: vals.Offset(),
		length: vals.Length(),
	}
}

// Name returns the name of the column
func (a *StringColumn) Name() string { return a.name }

// Length returns the number of rows in the column
func (a *StringColumn) Length() int { return int(a.length) }

// Type returns an integer specifying the data typed contained by the column
func (a *StringColumn) Type() int8 { return a.typE }

// TypeString returns a string describing the data typed contained by the column
func (a *StringColumn) TypeString() string { return fbs.EnumNamesTypE[int8(a.typE)] }

// NullN returns how many null values there are in the column
func (a *StringColumn) NullN() int64 { return a.nNull }

// StringFullColumn is a type that represents an immutable sequence of string values with no missing data
type StringFullColumn struct {
	name           string
	values         *fbs.PrimitiveArray
	src            *Source
	typE           int8
	offset, length int64
}

// NewStringFullColumn constructs a new StringFullColumn given the Source and column description from flatbuffers metadata
func NewStringFullColumn(src *Source, vals *fbs.PrimitiveArray, name string) *StringFullColumn {
	// TODO: typecheck for col.Values().TypE to match String
	if vals.TypE() != fbs.TypEUTF8 {
		panic("Expected type string, but found something else...")
	}
	return &StringFullColumn{
		name:   name,
		values: vals,
		src:    src,
		typE:   vals.TypE(),
		offset: vals.Offset(),
		length: vals.Length(),
	}
}

// ToFullColumn converts the Column to one without a bitmask, if possible. Will return an error if nulls are present
func (a *StringColumn) ToFullColumn() (*StringFullColumn, error) {
	if a.nNull > 0 {
		return nil, errors.New("Nulls present, cannot convert to full column")
	}
	out := &StringFullColumn{
		name:   a.name,
		values: a.values,
		src:    a.src,
		typE:   a.typE,
		offset: a.offset,
		length: a.length,
	}
	return out, nil
}

// ToFullColumn converts the Column to one without a bitmask, if possible. Will return an error if nulls are present
func (a *StringFullColumn) ToFullColumn() (*StringFullColumn, error) {
	return a, nil
}

// Name returns the name of the column
func (a *StringFullColumn) Name() string { return a.name }

// Length returns the number of rows in the column
func (a *StringFullColumn) Length() int { return int(a.length) }

// Type returns an integer specifying the data typed contained by the column
func (a *StringFullColumn) Type() int8 { return a.typE }

// TypeString returns a string describing the data typed contained by the column
func (a *StringFullColumn) TypeString() string { return fbs.EnumNamesTypE[int8(a.typE)] }

// NullN returns how many null values there are in the column
func (a *StringFullColumn) NullN() int64 { return 0 }

// BoolColumn is a type that represents an immutable sequence of bool values.
type BoolColumn struct {
	name           string
	values         *fbs.PrimitiveArray
	nNull          int64
	src            *Source
	typE           int8
	offset, length int64
}

// NewBoolColumn constructs a new BoolColumn given the Source and column description from flatbuffers metadata
func NewBoolColumn(src *Source, vals *fbs.PrimitiveArray, name string) *BoolColumn {
	// TODO: typecheck for col.Values().TypE to match Bool
	if vals.TypE() != fbs.TypEBOOL {
		panic("Expected type bool, but found something else...")
	}
	return &BoolColumn{
		name:   name,
		values: vals,
		nNull:  vals.NullCount(),
		src:    src,
		typE:   vals.TypE(),
		offset: vals.Offset(),
		length: vals.Length(),
	}
}

// Name returns the name of the column
func (a *BoolColumn) Name() string { return a.name }

// Length returns the number of rows in the column
func (a *BoolColumn) Length() int { return int(a.length) }

// Type returns an integer specifying the data typed contained by the column
func (a *BoolColumn) Type() int8 { return a.typE }

// TypeString returns a string describing the data typed contained by the column
func (a *BoolColumn) TypeString() string { return fbs.EnumNamesTypE[int8(a.typE)] }

// NullN returns how many null values there are in the column
func (a *BoolColumn) NullN() int64 { return a.nNull }

// BoolFullColumn is a type that represents an immutable sequence of bool values with no missing data
type BoolFullColumn struct {
	name           string
	values         *fbs.PrimitiveArray
	src            *Source
	typE           int8
	offset, length int64
}

// NewBoolFullColumn constructs a new BoolFullColumn given the Source and column description from flatbuffers metadata
func NewBoolFullColumn(src *Source, vals *fbs.PrimitiveArray, name string) *BoolFullColumn {
	// TODO: typecheck for col.Values().TypE to match Bool
	if vals.TypE() != fbs.TypEBOOL {
		panic("Expected type bool, but found something else...")
	}
	return &BoolFullColumn{
		name:   name,
		values: vals,
		src:    src,
		typE:   vals.TypE(),
		offset: vals.Offset(),
		length: vals.Length(),
	}
}

// ToFullColumn converts the Column to one without a bitmask, if possible. Will return an error if nulls are present
func (a *BoolColumn) ToFullColumn() (*BoolFullColumn, error) {
	if a.nNull > 0 {
		return nil, errors.New("Nulls present, cannot convert to full column")
	}
	out := &BoolFullColumn{
		name:   a.name,
		values: a.values,
		src:    a.src,
		typE:   a.typE,
		offset: a.offset,
		length: a.length,
	}
	return out, nil
}

// ToFullColumn converts the Column to one without a bitmask, if possible. Will return an error if nulls are present
func (a *BoolFullColumn) ToFullColumn() (*BoolFullColumn, error) {
	return a, nil
}

// Name returns the name of the column
func (a *BoolFullColumn) Name() string { return a.name }

// Length returns the number of rows in the column
func (a *BoolFullColumn) Length() int { return int(a.length) }

// Type returns an integer specifying the data typed contained by the column
func (a *BoolFullColumn) Type() int8 { return a.typE }

// TypeString returns a string describing the data typed contained by the column
func (a *BoolFullColumn) TypeString() string { return fbs.EnumNamesTypE[int8(a.typE)] }

// NullN returns how many null values there are in the column
func (a *BoolFullColumn) NullN() int64 { return 0 }

// NOTE: we need to special case Value and Values for StringColumn, that's
// why we have that if ne .Name "String" above. Below is the implementation

// Value extracts a single value from location i and whether that value is
// non-null. If null, then the result will be (0, false)
func (a *StringColumn) Value(i int) (string, bool) {
	off := a.offset
	if a.nNull > 0 {
		// There might be nulls -- need to check bit
		bitbyte := a.src.Data.At(int(off) + int(uint(i)/8)) // read single byte
		if (bitbyte & BitMask[i%8]) == 0 {                  // check if bit is set in byte
			return "", false
		}
		off += a.src.getBitmaskLength()
	}

	// need to compute offset start and end
	offsets := make([]int32, 2)
	buf := make([]byte, 8)
	a.src.Data.ReadAt(buf, off+int64(i*4))
	binary.Read(bytes.NewBuffer(buf), binary.LittleEndian, &offsets)

	// seek forward to end of offset portion of buffer
	off += getoutputlength(a.src.Ctable.Version(), 4*(a.length+1))

	// now need to extract value bytes from
	valbuf := make([]byte, offsets[1]-offsets[0])
	a.src.Data.ReadAt(valbuf, off+int64(offsets[0]))
	return string(valbuf), true
}

// Values extracts slices of all values as well as a []bool indicating validity
// of all elements. If there are no null values, then the second slice will be
// nil. An entry of false in the second slice indicates that the corresponding
// value is null
func (a *StringColumn) Values() ([]string, []bool) {
	off := a.offset
	length := a.length

	outVals := make([]string, length)
	var outValid []bool
	var bitmaskLength int64

	if a.nNull > 0 {
		outValid = make([]bool, length)
		bitmaskLength = a.src.getBitmaskLength()
		bitmask := make([]byte, bitmaskLength)
		a.src.Data.ReadAt(bitmask, off)
		for i := 0; i < int(length); i++ {
			outValid[i] = bitIsSet(bitmask, i)
		}
	}
	off += bitmaskLength

	// read offsets
	offsetbuf := make([]byte, 4*(length+1))
	a.src.Data.ReadAt(offsetbuf, off)
	offsets := arrow.Int32Traits.CastFromBytes(offsetbuf)

	// move offset forward
	off += getoutputlength(a.src.Ctable.Version(), 4*(length+1))

	// read in values
	for i := 0; i < int(length); i++ {
		bytes := make([]byte, offsets[i+1]-offsets[i])
		a.src.Data.ReadAt(bytes, off+int64(offsets[i]))
		outVals[i] = string(bytes)
	}
	return outVals, outValid
}

// Value extracts a single value from location i and whether that value is
// non-null. If null, then the result will be (0, false)
func (a *StringFullColumn) Value(i int) string {
	off := a.offset

	// need to compute offset start and end
	offsets := make([]int32, 2)
	buf := make([]byte, 8)
	a.src.Data.ReadAt(buf, off+int64(i*4))
	binary.Read(bytes.NewBuffer(buf), binary.LittleEndian, &offsets)

	// seek forward to end of offset portion of buffer
	off += getoutputlength(a.src.Ctable.Version(), 4*(a.length+1))

	// now need to extract value bytes from
	valbuf := make([]byte, offsets[1]-offsets[0])
	a.src.Data.ReadAt(valbuf, off+int64(offsets[0]))
	return string(valbuf)
}

// Values extracts a slice of all values
func (a *StringFullColumn) Values() []string {
	off := a.offset
	length := a.length

	outVals := make([]string, length)

	// read offsets
	offsetbuf := make([]byte, 4*(length+1))
	a.src.Data.ReadAt(offsetbuf, off)
	offsets := make([]int32, length+1)
	binary.Read(bytes.NewBuffer(offsetbuf), binary.LittleEndian, &offsets)

	// move offset forward
	off += getoutputlength(a.src.Ctable.Version(), 4*(length+1))

	// read in values
	for i := 0; i < int(length); i++ {
		bytes := make([]byte, offsets[i+1]-offsets[i])
		a.src.Data.ReadAt(bytes, off+int64(offsets[i]))
		outVals[i] = string(bytes)
	}
	return outVals
}

// Value extracts a single value from location i and whether that value is
// non-null. If null, then the result will be (false, false)
func (a *BoolColumn) Value(i int) (bool, bool) {
	var bitbyte byte
	off := a.offset
	if a.nNull > 0 {
		// There might be nulls -- need to check bit
		bitbyte = a.src.Data.At(int(off) + int(uint(i)/8)) // read single byte
		if (bitbyte & BitMask[i%8]) == 0 {                 // check if bit is set in byte
			return false, false
		}
		off += a.src.getBitmaskLength()
	}

	bitbyte = a.src.Data.At(int(off) + int(uint(i)/8)) // read single byte
	return bitbyte&BitMask[i%8] > 0, true
}

// Values extracts slices of all values as well as a []bool indicating validity
// of all elements. If there are no null values, then the second slice will be
// nil. An entry of false in the second slice indicates that the corresponding
// value is null
func (a *BoolColumn) Values() ([]bool, []bool) {
	off := a.offset
	length := a.length

	outVals := make([]bool, length)
	var outValid []bool
	var bitmaskLength int64

	if a.nNull > 0 {
		outValid = make([]bool, length)
		bitmaskLength = a.src.getBitmaskLength()
		bitmask := make([]byte, bitmaskLength)
		a.src.Data.ReadAt(bitmask, off)
		for i := 0; i < int(length); i++ {
			outValid[i] = bitIsSet(bitmask, i)
		}
	}
	off += bitmaskLength

	bitmask := make([]byte, a.src.getBitmaskLength())
	a.src.Data.ReadAt(bitmask, off)
	for i := 0; i < int(length); i++ {
		outVals[i] = bitIsSet(bitmask, i)
	}

	return outVals, outValid
}

// Value extracts a single value from location i and whether that value is
// non-null. If null, then the result will be (false, false)
func (a *BoolFullColumn) Value(i int) bool {
	off := a.offset
	bitbyte := a.src.Data.At(int(off) + int(uint(i)/8)) // read single byte
	return bitbyte&BitMask[i%8] > 0
}

// Values extracts slices of all values as well as a []bool indicating validity
// of all elements. If there are no null values, then the second slice will be
// nil. An entry of false in the second slice indicates that the corresponding
// value is null
func (a *BoolFullColumn) Values() []bool {
	off := a.offset
	length := a.length
	outVals := make([]bool, length)
	bitmask := make([]byte, a.src.getBitmaskLength())
	a.src.Data.ReadAt(bitmask, off)
	for i := 0; i < int(length); i++ {
		outVals[i] = bitIsSet(bitmask, i)
	}

	return outVals
}

// NewColumnArray constructs a FeatherColumn from a flatbuffers primitive array
func NewColumnArray(src *Source, vals *fbs.PrimitiveArray, name string) FeatherColumn {
	switch vals.TypE() {

	case fbs.TypEINT8:
		return NewInt8Column(src, vals, name)

	case fbs.TypEINT16:
		return NewInt16Column(src, vals, name)

	case fbs.TypEINT32:
		return NewInt32Column(src, vals, name)

	case fbs.TypEINT64:
		return NewInt64Column(src, vals, name)

	case fbs.TypEUINT8:
		return NewUint8Column(src, vals, name)

	case fbs.TypEUINT16:
		return NewUint16Column(src, vals, name)

	case fbs.TypEUINT32:
		return NewUint32Column(src, vals, name)

	case fbs.TypEUINT64:
		return NewUint64Column(src, vals, name)

	case fbs.TypEFLOAT:
		return NewFloat32Column(src, vals, name)

	case fbs.TypEDOUBLE:
		return NewFloat64Column(src, vals, name)

	case fbs.TypEUTF8:
		return NewStringColumn(src, vals, name)

	case fbs.TypEBOOL:
		return NewBoolColumn(src, vals, name)

	case fbs.TypECATEGORY:
		fmt.Println("Have TypECATEGORY")
		return nil
	case fbs.TypETIMESTAMP:
		fmt.Println("Have TypETIMESTAMP")
		return nil
	case fbs.TypEDATE:
		fmt.Println("Have TypEDATE")
		return nil
	case fbs.TypETIME:
		fmt.Println("Have TypETIME")
		return nil
	default:
		fmt.Println("No ideas what I just saw...")
		return nil
	}
}

// NewColumnFbsColumn constructs a FeatherColumn given src and Column
func NewColumnFbsColumn(src *Source, col *fbs.Column) FeatherColumn {
	vals := col.Values(nil)
	name := string(col.Name())
	column := NewColumnArray(src, vals, name)
	switch col.MetadataType() {
	case fbs.TypeMetadataNONE:
		return column // correct behavior
	case fbs.TypeMetadataCategoryMetadata:
		pool := NewCategoryMetadata(src, col)
		return DictColumn(column, pool)
	case fbs.TypeMetadataTimestampMetadata:
		fmt.Println("Have TypeMetadataTimestampMetadata")
	case fbs.TypeMetadataDateMetadata:
		fmt.Println("Have TypeMetadataDateMetadata")
	case fbs.TypeMetadataTimeMetadata:
		fmt.Println("Have TypeMetadataTimeMetadata")
	}
	// meta := metadataForCol(src, col)
	return column
}

// NewFullColumnArray constructs a FeatherColumn wihout a bitmask from a flatbuffers primitive array.
// An error is returned if there are nulls and a length-zero bitmask would be invalid
func NewFullColumnArray(src *Source, vals *fbs.PrimitiveArray, name string) (FeatherColumn, error) {
	if vals.NullCount() > 0 {
		err := errors.New("This column has null values, use `NewColumnArray instead`")
		return nil, err
	}
	switch vals.TypE() {

	case fbs.TypEINT8:
		return NewInt8FullColumn(src, vals, name), nil

	case fbs.TypEINT16:
		return NewInt16FullColumn(src, vals, name), nil

	case fbs.TypEINT32:
		return NewInt32FullColumn(src, vals, name), nil

	case fbs.TypEINT64:
		return NewInt64FullColumn(src, vals, name), nil

	case fbs.TypEUINT8:
		return NewUint8FullColumn(src, vals, name), nil

	case fbs.TypEUINT16:
		return NewUint16FullColumn(src, vals, name), nil

	case fbs.TypEUINT32:
		return NewUint32FullColumn(src, vals, name), nil

	case fbs.TypEUINT64:
		return NewUint64FullColumn(src, vals, name), nil

	case fbs.TypEFLOAT:
		return NewFloat32FullColumn(src, vals, name), nil

	case fbs.TypEDOUBLE:
		return NewFloat64FullColumn(src, vals, name), nil

	case fbs.TypEUTF8:
		return NewStringFullColumn(src, vals, name), nil

	case fbs.TypEBOOL:
		return NewBoolFullColumn(src, vals, name), nil

	case fbs.TypECATEGORY:
		fmt.Println("Have TypECATEGORY")
		return nil, nil
	case fbs.TypETIMESTAMP:
		fmt.Println("Have TypETIMESTAMP")
		return nil, nil
	case fbs.TypEDATE:
		fmt.Println("Have TypEDATE")
		return nil, nil
	case fbs.TypETIME:
		fmt.Println("Have TypETIME")
		return nil, nil
	default:
		fmt.Println("No ideas what I just saw...")
		return nil, nil
	}
}

// NewFullColumnFbsColumn constructs a full column given src and Column
func NewFullColumnFbsColumn(src *Source, col *fbs.Column) (FeatherColumn, error) {
	vals := col.Values(nil)
	name := string(col.Name())
	// meta := metadataForCol(src, col)
	return NewFullColumnArray(src, vals, name)
}

func metadataForCol(src *Source, col *fbs.Column) FeatherColumn {
	// Now work on metadta
	switch col.MetadataType() {
	case fbs.TypeMetadataNONE:
		return nil // correct behavior
	case fbs.TypeMetadataCategoryMetadata:
		return NewCategoryMetadata(src, col)
	case fbs.TypeMetadataTimestampMetadata:
		fmt.Println("Have TypeMetadataTimestampMetadata")
	case fbs.TypeMetadataDateMetadata:
		fmt.Println("Have TypeMetadataDateMetadata")
	case fbs.TypeMetadataTimeMetadata:
		fmt.Println("Have TypeMetadataTimeMetadata")
	}
	return nil
}

// NewCategoryMetadata constructs a FeatherColumn given a flatbuffers column and a source
func NewCategoryMetadata(src *Source, col *fbs.Column) FeatherColumn {
	if col.MetadataType() != fbs.TypeMetadataCategoryMetadata {
		return nil
	}
	var _catMeta flatbuffers.Table
	inited := col.Metadata(&_catMeta)
	if !inited {
		panic("couldn't load metadata")
	}

	var catmeta fbs.CategoryMetadata
	catmeta.Init(_catMeta.Bytes, _catMeta.Pos)
	lvls := catmeta.Levels(nil)
	return NewColumnArray(src, lvls, "")
}

// TODO: need to do category, timestamp, date, time, binary
